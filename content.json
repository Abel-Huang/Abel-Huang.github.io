[{"title":"Markdown基本用法小结","date":"2017-05-12T20:57:46.000Z","path":"2017/05/13/Markdown基本用法小结/","text":"标题语法123456# 这是 H1 一级标题## 这是 H2 二级标题### 这是 H3 三级标题#### 这是 H4 四级标题##### 这是 H5 五级标题###### 这是 H6 六级标题 效果 这是 H1 一级标题这是 H2 二级标题这是 H3 三级标题这是 H4 四级标题这是 H5 五级标题这是 H6 六级标题列表无序列表1234567891011121314151617181920* 项目1 * 子项目1.1 * 子项目1.2 * 子项目1.2.1* 项目2* 项目3+ 项目1 + 子项目1.1 + 子项目1.2 + 子项目1.2.1+ 项目2+ 项目3- 项目1 - 子项目1.1 - 子项目1.2 - 子项目1.2.1- 项目2- 项目3 有序列表12345678910111. 项目12. 项目23. 项目3 1. 项目3.1 2. 项目3.21. 项目11. 项目21. 项目3 1. 项目3.1 1. 项目3.2 有序列表起始编号1258. 项目52. 项目6 链接123[链接名称](链接地址)[链接名称][1][1] : 链接地址 图片123![名称](链接地址)![名称][1][1] : 链接地址 文字格式123456**这是文字粗体格式**__这是文字粗体格式__*这是文字斜体格式*_这是文字斜体格式_ 引用12&gt; 第一行引用文字&gt; 第二行引用文字 水平线1***","tags":[{"name":"Markdown","slug":"Markdown","permalink":"http://abelib.cn/tags/Markdown/"}]},{"title":"Linux学习笔记1：文件操作","date":"2017-05-11T21:01:46.000Z","path":"2017/05/12/Linux学习笔记1：文件操作/","text":"我在大四上学期的时候学习了一门Linux的课程，并且对Linux有了一点浅显的认识，但是除了完成最后的期末大作业，我和Linux基本上也没有发生什么交集了。三月底一个朋友内推我参加面试，面试官屡屡提到了Linux，虽然最终侥幸拿到了offer，但是我也意识到自己在Linux上面的薄弱。由于临近毕业，这也可能是最后的校园时光了，除了写论文做毕设也没有太多其他的事情，打算抽时间好好学习一下Linux。最近在学习Linux的命令行和shell编程，需要记忆和掌握的知识点很多，所以把一些经常用到的知识点记下来，加深一下印象。文件系统是Linux最重要的部分，甚至Linux就是基于文件的，文件操作是Linux使用中无法避免的。在Linux中文件操作的命令行主要有以下5类。12345* 浏览文件* 文件和目录列表* 处理文件* 处理目录* 查看文件 浏览文件在Linux系统中，可以用cd切换路径，其基本格式如下：1cd destination cd命令可以接受一个参数表示要打开的文件目录，而路径又分成相对路径和绝对路径。绝对路径以/开头，指虚拟文件系统的根路径，例如访问usr目录下的bin文件夹，就可以使用如下的绝对路径：1cd /usr/bin 而相对路径则是基于当前位置的目标文件路径，以目录名或者一个特殊字符开始。例如在home目录下，希望切换到Desktop目录下，使用相对目录会更加方便：1cd Desktop 此外还有一些特殊用法：cd 不加参数，回到home目录下cd ~ 同上cd ..回到当前目录的父目录cd .回到当前目录cd /回到根目录可以使用pwd获取当前目录所处的绝对路径。 文件和目录列表在Linux系统中可以使用ls命令查看文件。需要注意的是ls是按列以字母表排序的。1ls ls可以设置参数，例如：ls -a 查看隐藏文件ls -l 查看长文件，会显示文件的详细信息 ls还支持添加过滤器，用以过滤输出列表： ls -l a* 查看以a开头的文件 处理文件创建文件1touch newfile touch命令默认创建一个空文件 复制文件1cp source destination 如果目标文件不存在会新建一个和原文件内容相同的新文件，但是文件信息会变成全新的，如果目标文件已经存在则会覆盖原文件的内容。 移动文件1mv file directory 将目标文件移动到指定目录下。 删除文件1rm file 需要注意的是删除文件后无法恢复，所以要谨慎操作。 处理目录创建目录1mkdir directory 新建了一个空目录，如果需要创建多级目录则需要以下参数：1mkdir -p directory/subdir 删除目录1rmdir directory 但是rmdir只能用来删除空目录，如果目录不为空则不会删除该目录。对于还有大量文件的目录可以使用以下方法来删除：1rmdir -rf fulldir 使用-r和-f参数可以完全删除目录，并且不用担心报错。 查看文件内容查看文件类型1file filename 使用file命令可以查看文件的类型，甚至可以分辨出是文件还是一个目录。 查看文件内容cat命令1cat filename 会将文件里面所有内容进行展示。more命令1more filename 与cat不同more每次只会显示一页内容，可以使用space或者enter继续浏览，或者使用q退出，more只支持基本的文件移动。less命令1less filename less是比more更高级的的命令，与more相比提供了更多的操作。tail和head命令1tail filename 会显示文件最后几行的内容，默认是10行，也可以自己定义：1tail -8 filename 显示最后8行内容。head和tail的用法基本类似，这里就不再赘述了。","tags":[{"name":"Linux","slug":"Linux","permalink":"http://abelib.cn/tags/Linux/"}]},{"title":"Java包装类简介","date":"2017-05-11T20:14:46.000Z","path":"2017/05/12/Java包装类简介/","text":"Java是一种强类型语言，一种总是强制类型定义的语言，要求变量的使用要严格符合定义，所有变量都必须先定义后使用，因此必须为每一个变量声明一种类型。在Java中，一共有8种基本数据类型，其中有四种整型（int，short，long，byte）、两种浮点类型（float，double）、1种用于表示Unicode编码的字符单元的字符类型char和一种用于表示真值（布尔值）的boolean类型。但在实际使用中我们常常需要将int型这样的基本数据类型，转换成对象。例如在使用泛型程序设计时，我们需要指定一个类型参数用来指示元素的类型，但是这个类型参数必须使用引用类型（至于原因会在文章最后指出），即基本类型对应的对象。 1List&lt;Integer&gt; list=new ArrayList&lt;&gt;(); 这时我们就需要将基本数据类型转换为对应的对象包装器，每一个基本类型都有一个与之对应的类，这个类被称为包装器。对应关系如下： int : Integer long : Long float : Float double : Double short : Short byte : Byte char : Character boolean : Boolean void : Void比如我们可以这样使用。12int a=123;Integer b=new Integer(123); 从Java SE5开始自动包装功能能自动地将基本类型转换为包装器类型，并且可以反向转换。12Integer a =123;int b=a; 而在这之前，我们需要对此进行显示的转换，否则编译器就会报错。12Integer a=123;int b=a.intValue(); 至于为什么需要包装类，主要原因有两个： 便于类型转换，防止类型强转时发生异常和错误。 在某些需要传入Object类型的参数时，需要传入基本类型对应的包装类型。因为Java是一个完全面向对象的语言，但唯一的例外可能就是基本类型了，因为对象是存放在堆中的，但是基本数据类型是创建一个并非是引用的“自动”变量。这个变量直接存储”值”，并置于堆栈中，因此更高效。可见，包装类其实比基本数据类型是更加面向对象的。","tags":[{"name":"Java","slug":"Java","permalink":"http://abelib.cn/tags/Java/"},{"name":"面向对象","slug":"面向对象","permalink":"http://abelib.cn/tags/面向对象/"}]},{"title":"如何用Java写一个交换函数","date":"2017-05-11T20:01:46.000Z","path":"2017/05/12/如何用Java写一个交换函数/","text":"最近在写Java时突然遇到一个问题，就是怎样在Java中写一个函数，实现两个数的交换，这个问题在学习C或者C++的时候我们常用来描述值传递和地址传递的区别，例如在C++中这个函数可以这样写：1234void swap(int &amp;a,int &amp;b)&#123; int temp=a; a=b; b=temp;&#125; C语言可以用指针进行地址传递实现同样的功能。但是Java中并没有指针，而且引用也不能直接操作基本数据类型。难道可以直接写成这样么？1234public void swap(int a,int b)&#123; int temp=a; a=b; b=temp;&#125; 答案是显而易见的，这个swap函数和C/C++的值传递一样，并不能实现交换的效果。通过在网上找资料，我发现了一种比较巧妙的方法来实现这个问题。1234public void swap(int [] a)&#123; int temp=a[0]; a[0]=a[1]; a[1]=temp;&#125; 在调用时，需要新建一个长度为2的数组，将需要交换的两个放到数组里面去，并将数组作为参数 , 例如将a=1,b=2进行交换：123456789int a=1;int b=2;int arraySwap[]=new int[2];arraySwap[0]=a;arraySwap[1]=b;swap(arraySwap);a=arraySwap[0];b=arraySwap[1];//运算的结果：a=2,b=1 通过数组的方式只是其中一种方法，还可以通过成员变量的方式来实现。虽然这是一个很简单的问题，但是却很容易被忽视，我自己还真的没有想到。这里面也有一个小小的问题，虽然在Java可以实现和C/C++同样效果的交换函数，但是代码却复杂了很多，这样反而没有单独将其写成一个函数的必要了，虽然逻辑上清晰了很多。尽管Java取消了指针，但是有时候也会给我们的编程带来一些小小的麻烦吧。","tags":[{"name":"Java","slug":"Java","permalink":"http://abelib.cn/tags/Java/"},{"name":"C ++","slug":"C","permalink":"http://abelib.cn/tags/C/"},{"name":"C","slug":"C","permalink":"http://abelib.cn/tags/C/"}]},{"title":"Java比较器的使用","date":"2017-05-11T17:00:01.000Z","path":"2017/05/12/Java比较器的使用/","text":"在编程中我们常常需要对对象进行排序，而排序又必须根据对象的实际类型进行比较。Java中提供了两个比较器接口用于对象之间的比较，分别是java.lang包中的Comparable接口和java.util包中Comparator接口。下面分别对这两种使用方法进行简单介绍。第一种java.lang.Comparable接口，只需要实现compareTo()一个方法就可以实现比较功能，并且调用系统排序函数查看效果。代码如下：1234567891011121314151617181920212223242526272829303132333435363738import java.util.Arrays;public class Children implements Comparable&lt;Children&gt;&#123; private String name; private int age; public Children(String name,int age)&#123; this.name=name; this.age=age; &#125; public String toString()&#123;//重载toString()方法 return name+\"******\"+age; &#125; @Override public int compareTo(Children c) &#123; if(this.age&gt;=c.age) return 1; else return -1; &#125; public static void main(String []args)&#123; Children[] childrens=&#123;new Children(\"Helen\",8), new Children(\"David\",12), new Children(\"Andrew\",10), new Children(\"Angela\",7), new Children(\"Joe\",9)&#125;; Arrays.sort(childrens); for(Children ch: childrens)&#123; System.out.println(ch); &#125; &#125;&#125;/* 输出结果*Angela******7*Helen******8*Joe******9*Andrew******10*David******12*/ 采用这种方法，我们需要让比较的对象类实现这个接口，并且必须要重载int compareTo(Object o)方法，接受一个需要比较的同类型的对象，如果该对象小于参数返回负值，除此之外返回正值，这时排序以增序排列，反之则以降序排列。第二种import java.util.Comparator接口，该接口有多个方法，但是如果是完成最简单的比较和排序的话，仅仅实现int compare(T o1, T o2)方法即可。代码如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import java.util.Arrays;import java.util.Comparator;public class Student &#123; private String name; private int age; public Student(String name,int age)&#123; this.name=name; this.age=age; &#125; public String getName()&#123; return name; &#125; public int getAge()&#123; return age; &#125; public String toString()&#123; return name+\"******\"+age; &#125; public static class CompareStudents implements Comparator&lt;Student&gt;&#123; @Override public int compare(Student o1, Student o2) &#123; if (o1.getAge()&gt;=o2.getAge()) return 1; else return -1; &#125; &#125; public static void main(String []args)&#123; Student[] students=&#123;new Student(\"Helen\",8), new Student(\"David\",12), new Student(\"Andrew\",10), new Student(\"Angela\",7), new Student(\"Joe\",9)&#125;; Arrays.sort(students,new CompareStudents()); for(Student stu: students)&#123; System.out.println(stu); &#125; &#125;&#125;/* 输出结果*Angela******7*Helen******8*Joe******9*Andrew******10*David******12*/ 用这种方法，需要为比较的对象单独创建一个实现了Comparator接口的类，可以发现int compare(T o1, T o2)需要传入两个参数并且排序比较的规则与之前也是类似的。两种方法最后得到了完全一样的结果，但是Comparator接口还有很多其他方法，尤其是JDK1.8之后才添加的新的方法，所以会有更强大的功能。所以如果是仅仅实现基本的对象比较的话采用第一种就可以了，但是如果有更多需求的话，则需要采用第二种方法。Tips:至于为什么需要重写toString()方法，是因为在System.out.println()中输出的如果是对象，则会默认调用其toString()方法，而所有的默认方法都是输出其对象名和地址。","tags":[{"name":"Java","slug":"Java","permalink":"http://abelib.cn/tags/Java/"}]},{"title":"Hello World","date":"2017-05-10T20:50:47.806Z","path":"2017/05/11/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[{"name":"hexo","slug":"hexo","permalink":"http://abelib.cn/tags/hexo/"}]}]