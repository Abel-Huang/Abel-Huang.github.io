[{"title":"Java包装类简介","date":"2017-05-11T20:14:46.000Z","path":"2017/05/12/Java包装类简介/","text":"Java是一种强类型语言，一种总是强制类型定义的语言，要求变量的使用要严格符合定义，所有变量都必须先定义后使用，因此必须为每一个变量声明一种类型。在Java中，一共有8种基本数据类型，其中有四种整型（int，short，long，byte）、两种浮点类型（float，double）、1种用于表示Unicode编码的字符单元的字符类型char和一种用于表示真值（布尔值）的boolean类型。但在实际使用中我们常常需要将int型这样的基本数据类型，转换成对象。例如在使用泛型程序设计时，我们需要指定一个类型参数用来指示元素的类型，但是这个类型参数必须使用引用类型（至于原因会在文章最后指出），即基本类型对应的对象。 List&lt;Integer&gt; list=new ArrayList&lt;&gt;(); 这时我们就需要将基本数据类型转换为对应的对象包装器，每一个基本类型都有一个与之对应的类，这个类被称为包装器。对应关系如下： int : Integer long : Long float : Float double : Double short : Short byte : Byte char : Character boolean : Boolean void : Void比如我们可以这样使用。12int a=123;Integer b=new Integer(123); 从Java SE5开始自动包装功能能自动地将基本类型转换为包装器类型，并且可以反向转换。 12Integer a =123;int b=a; 而在这之前，我们需要对此进行显示的转换，否则编译器就会报错。12Integer a=123;int b=a.intValue(); 至于为什么需要包装类，主要原因有两个： 便于类型转换，防止类型强转时发生异常和错误。 在某些需要传入Object类型的参数时，需要传入基本类型对应的包装类型。因为Java是一个完全面向对象的语言，但唯一的例外可能就是基本类型了，因为对象是存放在堆中的，但是基本数据类型是创建一个并非是引用的“自动”变量。这个变量直接存储”值”，并置于堆栈中，因此更高效。可见，包装类其实比基本数据类型是更加面向对象的。","tags":[{"name":"Java","slug":"Java","permalink":"http://abelib.cn/tags/Java/"},{"name":"面向对象","slug":"面向对象","permalink":"http://abelib.cn/tags/面向对象/"}]},{"title":"myFirstPageForTag","date":"2017-05-11T20:01:46.000Z","path":"2017/05/12/myFirstPageForTag/","text":"","tags":[{"name":"html","slug":"html","permalink":"http://abelib.cn/tags/html/"},{"name":"css","slug":"css","permalink":"http://abelib.cn/tags/css/"},{"name":"js","slug":"js","permalink":"http://abelib.cn/tags/js/"}]},{"title":"如何用Java写一个交换函数","date":"2017-05-11T20:01:46.000Z","path":"2017/05/12/如何用Java写一个交换函数/","text":"最近在写Java时突然遇到一个问题，就是怎样在Java中写一个函数，实现两个数的交换，这个问题在学习C或者C++的时候我们常用来描述值传递和地址传递的区别，例如在C++中这个函数可以这样写：12345//cppvoid swap(int &amp;a,int &amp;b)&#123; int temp=a; a=b; b=temp;&#125; C语言可以用指针进行地址传递实现同样的功能。但是Java中并没有指针，而且引用也不能直接操作基本数据类型。难道可以直接写成这样么？ 12345//Javapublic void swap(int a,int b)&#123; int temp=a; a=b; b=temp;&#125; 答案是显而易见的，这个swap函数和C/C++的值传递一样，并不能实现交换的效果。通过在网上找资料，我发现了一种比较巧妙的方法来实现这个问题。 12345//Javapublic void swap(int [] a)&#123; int temp=a[0]; a[0]=a[1]; a[1]=temp;&#125; 在调用时，需要新建一个长度为2的数组，将需要交换的两个放到数组里面去，并将数组作为参数 , 例如将a=1,b=2进行交换：12345678910//Javaint a=1;int b=2;int arraySwap[]=new int[2];arraySwap[0]=a;arraySwap[1]=b;swap(arraySwap);a=arraySwap[0];b=arraySwap[1];//运算的结果：a=2,b=1 通过数组的方式只是其中一种方法，还可以通过成员变量的方式来实现。虽然这是一个很简单的问题，但是却很容易被忽视，我自己还真的没有想到。这里面也有一个小小的问题，虽然在Java可以实现和C/C++同样效果的交换函数，但是代码却复杂了很多，这样反而没有单独将其写成一个函数的必要了，虽然逻辑上清晰了很多。尽管Java取消了指针，但是有时候也会给我们的编程带来一些小小的麻烦吧。","tags":[{"name":"Java","slug":"Java","permalink":"http://abelib.cn/tags/Java/"},{"name":"C ++","slug":"C","permalink":"http://abelib.cn/tags/C/"},{"name":"C","slug":"C","permalink":"http://abelib.cn/tags/C/"}]},{"title":"Java比较器的使用","date":"2017-05-11T17:00:01.000Z","path":"2017/05/12/Java比较器的使用/","text":"在编程中我们常常需要对对象进行排序，而排序又必须根据对象的实际类型进行比较。Java中提供了两个比较器接口用于对象之间的比较，分别是java.lang包中的Comparable接口和java.util包中Comparator接口。下面分别对这两种使用方法进行简单介绍。第一种java.lang.Comparable接口，只需要实现compareTo()一个方法就可以实现比较功能，并且调用系统排序函数查看效果。代码如下： 123456789101112131415161718192021222324252627282930313233343536373839//Javaimport java.util.Arrays;public class Children implements Comparable&lt;Children&gt;&#123; private String name; private int age; public Children(String name,int age)&#123; this.name=name; this.age=age; &#125; public String toString()&#123;//重载toString()方法 return name+\"******\"+age; &#125; @Override public int compareTo(Children c) &#123; if(this.age&gt;=c.age) return 1; else return -1; &#125; public static void main(String []args)&#123; Children[] childrens=&#123;new Children(\"Helen\",8), new Children(\"David\",12), new Children(\"Andrew\",10), new Children(\"Angela\",7), new Children(\"Joe\",9)&#125;; Arrays.sort(childrens); for(Children ch: childrens)&#123; System.out.println(ch); &#125; &#125;&#125;/* 输出结果*Angela******7*Helen******8*Joe******9*Andrew******10*David******12*/ 采用这种方法，我们需要让比较的对象类实现这个接口，并且必须要重载int compareTo(Object o)方法，接受一个需要比较的同类型的对象，如果该对象小于参数返回负值，除此之外返回正值，这时排序以增序排列，反之则以降序排列。第二种import java.util.Comparator接口，该接口有多个方法，但是如果是完成最简单的比较和排序的话，仅仅实现int compare(T o1, T o2)方法即可。代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748//Javaimport java.util.Arrays;import java.util.Comparator;public class Student &#123; private String name; private int age; public Student(String name,int age)&#123; this.name=name; this.age=age; &#125; public String getName()&#123; return name; &#125; public int getAge()&#123; return age; &#125; public String toString()&#123; return name+\"******\"+age; &#125; public static class CompareStudents implements Comparator&lt;Student&gt;&#123; @Override public int compare(Student o1, Student o2) &#123; if (o1.getAge()&gt;=o2.getAge()) return 1; else return -1; &#125; &#125; public static void main(String []args)&#123; Student[] students=&#123;new Student(\"Helen\",8), new Student(\"David\",12), new Student(\"Andrew\",10), new Student(\"Angela\",7), new Student(\"Joe\",9)&#125;; Arrays.sort(students,new CompareStudents()); for(Student stu: students)&#123; System.out.println(stu); &#125; &#125;&#125;/* 输出结果*Angela******7*Helen******8*Joe******9*Andrew******10*David******12*/ 用这种方法，需要为比较的对象单独创建一个实现了Comparator接口的类，可以发现int compare(T o1, T o2)需要传入两个参数并且排序比较的规则与之前也是类似的。两种方法最后得到了完全一样的结果，但是Comparator接口还有很多其他方法，尤其是JDK1.8之后才添加的新的方法，所以会有更强大的功能。所以如果是仅仅实现基本的对象比较的话采用第一种就可以了，但是如果有更多需求的话，则需要采用第二种方法。Tips:至于为什么需要重写toString()方法，是因为在System.out.println()中输出的如果是对象，则会默认调用其toString()方法，而所有的默认方法都是输出其对象名和地址。","tags":[{"name":"Java","slug":"Java","permalink":"http://abelib.cn/tags/Java/"}]},{"title":"Hello world","date":"2017-05-10T21:50:30.000Z","path":"2017/05/11/Hello-world-0/","text":"你好， 欢迎来到我的个人技术博客。","tags":[{"name":"tags","slug":"tags","permalink":"http://abelib.cn/tags/tags/"}]},{"title":"Hello World","date":"2017-05-10T20:50:47.806Z","path":"2017/05/11/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]}]